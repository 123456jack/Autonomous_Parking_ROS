/*=================================================================
 *
 * 16-782 Planning & Decision-Making for Robotics
 * Final Project: Auto Park
 * planner functions
 *
 *=================================================================*/
// primArray[i][j] 代表第i个motion primitive 的第j个元素， ，j= 0是x，j= 1 是y, j=2 是theta
// 不是 是一个vector<vector<vector<vector<float>>>>
//ROS_INFO("");

#include <planner.h>

// inputs are in gazebo coordination
void planner::initialize(int** map_input, float startx, float starty, float starttheta,
	              float goalx, float goaly, float goaltheta) {
	// initialize map
	map_original = map_input;
	x_size = 380;
	y_size = 330;
	//initialize car parameters
	car_wid = 2;
	car_len = 5;
	car_exlen = car_len / 2 + 0.5;
	alpha = atan(car_wid / car_len) / M_PI * 180;
	beta = atan(car_wid / 2 / car_exlen) / M_PI * 180;
	car_diag = sqrt((car_wid / 2 ) * (car_wid / 2) + (car_len / 2 ) * (car_len / 2));
	car_exdiag = sqrt((car_wid / 2 ) * (car_wid / 2) + car_exlen * car_exlen);

	// cost array initialization
	cost_list[0] = 1;
	cost_list[1] = 0.5;
	cost_list[2] = 1;
	cost_list[3] = 0.5;
	cost_list[4] = 1;
	cost_list[5] = 1;
	cost_list[6] = 1;
	cost_list[7] = 1;
	eps = 10;

	// initialize Prim Array
	nprim = 36;

	// initialize start node
	float start_x_inner = startx;
	float start_y_inner = starty + 33;
	if (starttheta < 0)
	{
		starttheta += 2 * M_PI;
	}
	float start_theta_inner = starttheta / M_PI * 180;
	int start_ID = getMapID(start_x_inner, start_y_inner, start_theta_inner);
	float start_v = std::numeric_limits<float>::max();
	start_node = new node(start_x_inner, start_y_inner, start_theta_inner,
		                         0, start_v, 0, 0,
								             -1);
	// initialize goal node
	float goal_x_inner = goalx;
	float goal_y_inner = goaly + 33;
	if (goaltheta < 0) {
		goaltheta = goaltheta + 2 * M_PI;
	}
	float goal_theta_inner = goaltheta / M_PI * 180;
	float goal_g = std::numeric_limits<float>::max();
	goal_node = new node(goal_x_inner, goal_y_inner, goal_theta_inner,
		                         goal_g, goal_g, 0, goal_g,
								             -1);
	// goal_x = goalx;
	// goal_y = goaly;
	// goal_theta = goaltheta;
	goal_ID = getMapID(goal_node->x_, goal_node->y_, goal_node->theta_);

	publish_x = start_node->x_;
	publish_y = start_node->y_;
	publish_theta = start_node->theta_;
	publish_primID = -1;
}

void planner::refresh()
{
	open.CleanUp();
	closed.clear();
	INCONS.clear();

	eps = 10;

	// float start_x_inner = startx;
	// float start_y_inner = starty + 33;
	// if (starttheta < 0)
	// {
	// 	starttheta += 2 * M_PI;
	// }
	// float start_theta_inner = starttheta / M_PI * 180;
	// int start_ID = getMapID(start_x_inner, start_y_inner, start_theta_inner);
	// float start_v = std::numeric_limits<float>::max();
	// start_node = new node(start_x_inner, start_y_inner, start_theta_inner,
	// 	                         0, start_v, 0, 0,
	// 							             -1);
	// initialize goal node

	float goal_g = std::numeric_limits<float>::max();
	goal_node->g_ = goal_g;
	goal_node->h_ = 0.0;
	goal_node->v_ = goal_g;
	goal_node->f_ = goal_g;
	goal_node->prim_ = -1;
	// goal_x = goalx;
	// goal_y = goaly;
	// goal_theta = goaltheta;
	goal_ID = getMapID(goal_node->x_, goal_node->y_, goal_node->theta_);


}
// inner coordination
inline int planner::getMapID(float x, float y, float theta) {
	return int(x / 0.1) * 36 + int(y / 0.1) * 36 * x_size + theta / 10;
}

// Use manhattan distance for heuristic function (inner coordination)
float planner::computeHeuristic(float x, float y, float theta) {
  return fabs(x - goal_node->x_) + fabs(y - goal_node->y_);
}


// inner coordination
bool planner::applyAction(float curx, float cury ,float curtheta,
		     		      float *succx, float *succy, float *succtheta, int np) {
 // ROS_INFO("entering apply action");
	float x, y;
	float theta;
	int si = curtheta / 10;
	x = curx;
	y = cury;
	theta = curtheta;
	int i;
	for (i = 0; i < 6; i++) {
		//apply partial primitive
		// ROS_INFO("si: %d", si);
		// ROS_INFO("np: %d", np);
		// ROS_INFO("i: %d", i);
		x = curx + primArray[si][np][i * 3];
		// ROS_INFO("x: %lf",x);
		y = cury + primArray[si][np][i * 3 + 1];
		// ROS_INFO("y: %lf",x);
		theta = primArray[si][np][i * 3 + 2] / M_PI * 180;
		// ROS_INFO("theta: %f", theta);
		// ROS_INFO("theta :%lf",theta);
		//check collision
		// ROS_INFO("start check collision");
		if (!checkCollision(x, y, theta)) {
			// ROS_INFO("not check collision");
			return false;
		}
		if (x <= 0 || x >= 38 || y <= 0 || y >= 33) {
			return false;
		}
	}
	*succx = x;
	*succy = y;
	*succtheta = theta;
	return true;
}

// inner coordination
bool planner::checkCollision(float x, float y, float theta) {
	// check mass center
	// int center_ID = getMapID(x, y, theta);
	float c_x = x;
	float c_y = y;
	if (c_x >= 38 || c_x <= 0) return false;
	if (c_y >= 33 || c_y <= 0) return false;
	if (map[int(fabs(c_y - 33) / 0.1)][int(c_x / 0.1)]) return false;
	// check four corner
	float left_top_x = x + car_diag * cos((theta + alpha) / 180 * M_PI);
	float left_top_y = y + car_diag * sin((theta + alpha) / 180 * M_PI);
	if (left_top_x >= 38 || left_top_x <= 0) return false;
	if (left_top_y >= 33 || left_top_y <= 0) return false;
	if (map[int(fabs(left_top_y - 33) / 0.1)][int(left_top_x / 0.1)]) return false;

	float right_top_x = x + car_diag * cos((theta - alpha) / 180 * M_PI);
	float right_top_y = y + car_diag * sin((theta - alpha) / 180 * M_PI);
	if (right_top_x >= 38 || right_top_x <= 0) return false;
	if (right_top_y >= 33 || right_top_y <= 0) return false;
	if (map[int(fabs(right_top_y - 33) / 0.1)][int(right_top_x / 0.1)]) return false;

	float left_bottom_x = x + car_diag * cos((theta + 180 - alpha) / 180 * M_PI);
	float left_bottom_y = y + car_diag * sin((theta + 180 - alpha) / 180 * M_PI);
	if (left_bottom_x >= 38 || left_bottom_x <= 0) return false;
	if (left_bottom_y >= 33 || left_bottom_y <= 0) return false;
	if (map[int(fabs(left_bottom_y - 33) / 0.1)][int(left_bottom_x / 0.1)]) return false;

	float right_bottom_x = x + car_diag * cos((theta + 180 + alpha) / 180 * M_PI);
	float right_bottom_y = y + car_diag * sin((theta + 180 + alpha) / 180 * M_PI);
	if (right_bottom_x >= 38 || right_bottom_x <= 0) return false;
	if (right_bottom_y >= 33 || right_bottom_y <= 0) return false;
	if (map[int(fabs(right_bottom_y - 33) / 0.1)][int(right_bottom_x / 0.1)]) return false;

	return true;
}

bool planner::checkGoal(node* node) {
	// float r_x = node->x_ - goal_x;
	// float r_y = node->y_ - goal_y;
	// float d_theta = node->theta_ - goal_theta;
	// if ((r_x * r_x + r_y * r_y) < 0.1 && dtheta < 5) {
	//   return true;
	// }
	// return false;
	// ROS_INFO("what");
	int ID = getMapID(node->x_, node->y_, node->theta_);
  // ROS_INFO("the");
	if (ID == goal_ID) return true;
	// ROS_INFO("fuck");
	return false;
}

void planner::trackPath() {
	// back track for path
	ROS_INFO("one");
	std::unordered_map<int, node*>::const_iterator bt_it = closed.find(goal_ID);
	if (bt_it == closed.end()) {
		ROS_WARN("[planner::trackPath] goalID not found...");
		this->publish_primID = -1;
		return;
	}
	node* bt_node = bt_it->second;
	// check whether this node is NULL
	if (!bt_node) {
		ROS_WARN("[planner::trackPath] Goal node is empty.");
		this->publish_primID = -1;
		return;
	} else {
		ROS_INFO("[planner::trackPath] Goal node ADDR: %p.", bt_node);
		ROS_INFO("[planner::trackPath] Its parent is @%p.", bt_node->parent_);
	}
	float bt_x = bt_node->parent_->x_;
	float bt_y = bt_node->parent_->y_;
	float bt_theta = bt_node->parent_->theta_;
	ROS_INFO("bt_x = %lf, bt_y = %lf, bt_theta = %lf", bt_x, bt_y, bt_theta);
	int bt_ID = getMapID(bt_x, bt_y, bt_theta);
	ROS_INFO("cur ID: %d", bt_ID);
	start_ID = getMapID(start_node->x_, start_node->y_, start_node->theta_);
	ROS_INFO("start ID: %d", start_ID);
	ROS_INFO("two");
	while (bt_ID != start_ID) {
		ROS_INFO("1");
		bt_node = bt_node->parent_;
		ROS_INFO("2");
		bt_x = bt_node->parent_->x_;
		ROS_INFO("3");
		bt_y = bt_node->parent_->y_;
		ROS_INFO("4");
	  bt_theta = bt_node->parent_->theta_;
		ROS_INFO("5");
		bt_ID = getMapID(bt_x, bt_y, bt_theta);
		ROS_INFO("id: %d", bt_ID);
	}
	publish_primID = bt_node->prim_;
	ROS_INFO("ID : %d", publish_primID);
}

void planner::update_map(float x, float y, float theta) {
	float x_tmp, y_tmp;
	for (int i = 0; i < y_size; i++) {
		for (int j = 0; j < x_size; j++) {
			map[i][j] = map_original[i][j];
		}
	}
	// bottom right position for obstacle car
	float br_x = x + car_diag * cos((theta + 180.0 + alpha) / 180 * M_PI);
	float br_y = y + car_diag * sin((theta + 180.0 + alpha) / 180 * M_PI);
	// top right position
	float tr_x = x + car_exdiag * cos((theta - alpha) / 180 * M_PI);
	float tr_y = y + car_exdiag * sin((theta - alpha) / 180 * M_PI);
	// bottom left positoin
	float bl_x = x + car_diag * cos((theta + 180.0 - alpha) / 180 * M_PI);
	float bl_y = y + car_diag * sin((theta + 180.0 - alpha) / 180 * M_PI);
	// vector for updating map
	float e1[2]; // width
	e1[0] = tr_x - br_x;
	e1[1] = tr_y - br_y;
	// normalization and scale to length of 0.1
	e1[0] = e1[0] / car_wid * 0.1;
	e1[1] = e1[1] / car_wid * 0.1;
	float e2[2]; // length
	e2[0] = bl_x - br_x;
	e2[1] = bl_y - br_y;
	// normalization and scale to length of 0.1
	e2[0] = e2[0] / car_exlen * 0.1;
	e2[1] = e2[1] / car_exlen * 0.1;

	int y_num = (car_len + 0.5) / 0.1;
	int x_num = car_wid / 0.1;
	int i = 0;
	int j = 0;
	while (i < x_num) {
		x_tmp = x + i * e1[0] + j * e2[0];
		while (j < y_num) {
			y_tmp = y + i * e1[1] + j * e2[1];
			if (y_tmp >= 33 || y_tmp <= 0 || x_tmp >= 38 || x_tmp <= 0) continue;
			// ROS_INFO("check1!");
			map[int(fabs(y_tmp - 33) / 0.1)][int(x_tmp / 0.1)] = 1;
			// ROS_INFO("check2!");
			j++;
		}
		i++;
		// ROS_INFO("check4!");
	}
	// ROS_INFO("check3!");
}

void planner::setPrimitives(std::vector<std::vector<std::vector<float>>> prim) {
	primArray = prim;
}

//Planner that takes inputs and generates first primitive(x,y,th)
void planner::computePath() {
	bool goal_found = false;
	// ROS_INFO("2!");
	while (open.GetN() != 0  && goal_node->f_ > open.GetValue(open.First())->f_) {
		// get the node with smallest f value from open list
		// ROS_INFO("3!");
		auto current_nodeHd = open.First();
		node* cur_node = open.GetValue(current_nodeHd);

		// Add to closed list
		// ROS_INFO("4!");
		int cur_ID = getMapID(cur_node->x_, cur_node->y_, cur_node->theta_);
		closed[cur_ID] = cur_node;
		// ROS_INFO("cur x: %f, y: %f, theta: %f", cur_node->x_, cur_node->y_, cur_node->theta_);
		// ROS_INFO("cur ID: %d", cur_ID);
		// ROS_INFO("clsoed list size: %d", closed.size());
		// // remove from open list
		// ROS_INFO("5!");
		cur_node->v_ = cur_node->g_;
		open.Delete(current_nodeHd);
		ID2node.erase(cur_ID);


		// check if it's goal
		// ROS_INFO("6!");
		if (checkGoal(cur_node)) {
			goal_found = true;
			// std::cout << "path found!" << std::endl;
			ROS_INFO("Path Found");
			break;
		}
		// ROS_INFO("6.5!");

		// apply different motion primitives to get successor
		// int theta_set_ID = cur_node->theta_ / 10;
		for (int np = 0; np < 8; np++) {
			// check if this action is feasible
			// ROS_INFO("7!");
			float succ_x, succ_y, succ_theta;
			bool ret = applyAction(cur_node->x_, cur_node->y_, cur_node->theta_,
				                     &succ_x, &succ_y, &succ_theta, np);

			if (ret) {
				// ROS_INFO("8!");
				// if it's a feasible successor
				int succ_ID = getMapID(succ_x, succ_y, succ_theta);
				// if it's never visited ARA* before
				node* succ_node;
				std::unordered_map<int, bool>::const_iterator visited_it = visited_list.find(succ_ID);
				if (visited_it == visited_list.end()) {
					float succ_g = std::numeric_limits<float>::max();
					float succ_v = succ_g;
					float succ_h = computeHeuristic(succ_x, succ_y, succ_theta);
					float succ_f = succ_g;
					succ_node = new node(succ_x, succ_y, succ_theta,
					                           succ_g, succ_v, succ_h, succ_f,
												             np);
				  succ_node->parent_ = cur_node;
					visited_list[succ_ID] = true;

				} else {
					// ROS_INFO("9!");
					// if it's been visited, find it in closed, open or INCONS
					// check closed
					std::unordered_map<int, node*>::const_iterator closed_it = closed.find(succ_ID);
					if (closed_it != closed.end()) {
						// in closed
						succ_node = closed_it->second;
					}
					// check open
					std::unordered_map<int, BinaryTree<float, node*>::NodeHandle>::const_iterator open_it_Hd = ID2node.find(succ_ID);
					if (open_it_Hd != ID2node.end()) {
						auto succ_node_Hd = open_it_Hd->second;
						succ_node = open.GetValue(succ_node_Hd);
					}
					// check INCONS
					std::unordered_map<int, node*>::const_iterator INCONS_it = INCONS.find(succ_ID);
					if (INCONS_it != INCONS.end()) {
						succ_node = INCONS_it->second;
					}
				}

				// OK, we find our succ_node here...
				if (succ_node->g_ > cur_node->g_ + cost_list[np]) {
					succ_node->g_ = cur_node->g_ + cost_list[np];
					succ_node->f_ = succ_node->g_ + eps * succ_node->h_;
					// check if it's in closed
					std::unordered_map<int, node*>::const_iterator closed_it = closed.find(succ_ID);
					if (closed_it == closed.end()) {
						// if it's not in closed list
						// check if it's in open list
						std::unordered_map<int, BinaryTree<float, node*>::NodeHandle>::const_iterator open_it_Hd = ID2node.find(succ_ID);
						if (open_it_Hd == ID2node.end()) {
							// not in open list
							// insert in open list
							auto succ_node_Hd = open.Insert(succ_node->f_, succ_node);
							ID2node[succ_ID] = succ_node_Hd;
							succ_node->parent_ = cur_node;
						} else {
							// in open list
							// delete the origin node in open and insert succ_node
							auto targetHd = open_it_Hd->second;
							auto target_node = open.GetValue(targetHd);
							open.Delete(targetHd);
							auto succ_node_Hd = open.Insert(succ_node->f_, succ_node);
							ID2node[succ_ID] = succ_node_Hd;
							// NEED TO UPDATE PARENT HERE
						}
					} else {
						// within closed list
						// NEED TO UPDATE ITS PARENT HERE, TOO
						// insert into INCONS
						INCONS[succ_ID] = succ_node;
						// delet from closed
						// NO, NO, NO, STILL WITHIN THE CLOSED LIST
						closed.erase(succ_ID);
					} // if (closed_it == closed.end())
				} // if (succ_node->g_ > cur_node->g_ + cost_list[np])
			} // if (ret)
		}
	}
	if (goal_found) {
		trackPath();
	} else {
		// ROS_INFO("open list size: %d",open.GetN());
		publish_primID = -1;
	}

}

void planner::setGoal(float x, float y, float theta) {
	y = y + 33;
	if (theta < 0)
	{
		theta += 2*M_PI;
	}
	theta = theta / M_PI * 180 / 10;
	theta = theta * 10;
	goal_node->x_ = x;
	goal_node->y_ = y;
	goal_node->theta_ = theta;
	goal_node->h_ = computeHeuristic(goal_node->x_, goal_node->y_, goal_node->theta_);
	goal_node->g_ = std::numeric_limits<float>::max();
	goal_node->v_ = goal_node->v_;
	goal_node->f_ = goal_node->g_;
	goal_node->prim_ = -1;
}

// main function
void planner::ARAstar(float x, float y, float theta, float obx, float oby, float obtheta) {
	ROS_INFO("entering ARA star!");
	ROS_INFO("goal node x: %lf, y: %lf, theta: %lf", goal_node->x_, goal_node->y_, goal_node->theta_);

	// refresh();

	// set time limit for each call to ARAstar
	double time_limit = 0.15;
	// coordination convertion
	y = y + 33;
	if (theta < 0)
	{
		theta += 2*M_PI;
	}
	theta = theta / M_PI * 180 / 10;
	theta = theta * 10;
	if (obtheta < 0)
	{
		obtheta += 2*M_PI;
	}
	obtheta = obtheta / M_PI * 180 / 10;
	obtheta = theta * 10;
	oby = oby + 33;
	ROS_INFO("start updating map!");
	update_map(obx,oby,obtheta);
	ROS_INFO("map updated!");

	// start time
	std::chrono::steady_clock::time_point time_1 = std::chrono::steady_clock::now();
	// initial epsilon
	eps = 10.0;
	// initialize start position
	start_node->x_ = x;
	start_node->y_ = y;
	start_node->theta_ = theta;
	ROS_INFO("start node x: %lf, y: %lf, theta: %lf", start_node->x_, start_node->y_, start_node->theta_);

	// set start node values
	start_node->g_ = 0;
	start_node->v_ = std::numeric_limits<float>::max();
	start_node->h_ = computeHeuristic(start_node->x_, start_node->y_, start_node->theta_);
	start_node->f_ = start_node->g_ + start_node->h_ * eps;
	start_node->prim_ = -1;
	start_node->parent_ = NULL;

	publish_x = start_node->x_;
	publish_y = start_node->y_;
	publish_theta = start_node->theta_;
	publish_primID = -1;
	// insert start node into open tree
	auto robot_start_leaf = open.Insert(start_node->f_, start_node);
	// int start_key = node2key(start_node, x_size, y_size);
	int start_ID = getMapID(start_node->x_, start_node->y_, start_node->theta_);
	ROS_INFO("start: %d", start_ID);
	// key2node[start_key] = robot_start_leaf;
	ID2node[start_ID] = robot_start_leaf;
	ROS_INFO("1!");
	computePath();


	// end time of 1st iteration
	std::chrono::steady_clock::time_point time_2 = std::chrono::steady_clock::now();
  std::chrono::duration<double> time_in_planning = std::chrono::duration_cast<std::chrono::duration<double>>(time_2-time_1);
  std::cout<<"Time used in searching: "<<time_in_planning.count()<<" seconds."<<std::endl;
	// while loop
	while(time_in_planning.count() < time_limit && eps > 1.0)
	{
		// decrease epsilon
		eps = eps - 1.0;
		ROS_INFO("eps: %f", eps);
		// move all INCONS into OPEN
		 ROS_INFO("open list size before: %d",open.GetN());
		for (auto incons_node : INCONS)
		{
			auto incons_node_leaf = open.Insert(incons_node.second->f_, incons_node.second);
			int incons_node_key = getMapID(incons_node.second->x_, incons_node.second->y_, incons_node.second->theta_);
			ID2node[incons_node_key] = incons_node_leaf;
		}
		 ROS_INFO("open list size after: %d",open.GetN());
		INCONS.clear();
		goal_node->f_ = goal_node->g_ + eps * goal_node->h_;

		for (auto node_id2node : ID2node)
		{
			node* temp_node;
			auto succ_node_hd = node_id2node.second;
			auto succ_node_id = node_id2node.first;
			temp_node = open.GetValue(succ_node_hd);
			open.Delete(succ_node_hd);
			temp_node->f_ = temp_node->g_ + eps * temp_node->h_;
			succ_node_hd = open.Insert(temp_node->f_, temp_node);
			ID2node[succ_node_id] = succ_node_hd;
		}
		// auto succ_node_Hd = open_it_Hd->second;
		// succ_node = open.GetValue(succ_node_Hd);
		// else {
		// 	// in open list
		// 	// delete the origin node in open and insert succ_node
		// 	auto targetHd = open_it_Hd->second;
		// 	auto target_node = open.GetValue(targetHd);
		// 	open.Delete(targetHd);
		// 	auto succ_node_Hd = open.Insert(succ_node->f_, succ_node);
		// 	ID2node[succ_ID] = succ_node_Hd;


		// clear CLOSED
		closed.clear();

		computePath();


		// pulish current

		// end time of each iteration
		std::chrono::steady_clock::time_point time_2 = std::chrono::steady_clock::now();
	  std::chrono::duration<double> time_in_planning = std::chrono::duration_cast<std::chrono::duration<double>>(time_2-time_1);
	  std::cout<<"Time used in searching: "<<time_in_planning.count()<<" seconds."<<std::endl;
	}
	ROS_INFO("primID: %d", publish_primID);
}
